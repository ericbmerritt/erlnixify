{"name":"Erlnixify","tagline":"A system to help Erlang integrate into Unix systems (supporting things like daemontools).","body":"Erlnixify\r\n=========\r\n\r\nErlang has the problem that it does not integrate nicely with\r\nUnix-like systems. It can not be put under things like\r\ndeamon-tools. You can't trap signals and respond appropriately,\r\netc. This is a small ruby program that serves as a 'front' to an\r\nErlang node. It allows a system like `init.d` or `daemontools` to\r\nmanage Erlnixify and Erlnixify will in-turn manage the Erlang node\r\nusing standard OTP inputs.\r\n\r\nFor example, when Erlnixify recieves a SIGTERM signal, it will call\r\n`init:stop()` on the Erlang node. This allows Erlang's release handler\r\nto do an orderly shutdown of the Erlang Node.\r\n\r\nErlnixify ensures that the Erlang node is up and running and checks\r\nevery few seconds (a configurable value) to see if everything is\r\ncontinueing to run correctly. If those checks fail, Erlnixify will\r\nshut down the Erlang node and then shut itself down so that whatever\r\nis managing the system can restart.\r\n\r\nErlnixify is designed to simply front the Erlang node. It does not\r\nprovide restarts, log rotation, or anything like that. Those things\r\nare expected to be provided by the system (daemontools again).\r\n\r\nErlnixify can be configured from the command line or via a config\r\nfile. Command line configuration overrides config file\r\nconfiguration. That is, if a configuration value is provided both on\r\nthe command line and in the config file, the value on the command line\r\nis the one that will be used.\r\n\r\n** Erlnixify is designed to manage releases. **\r\n** For self contained releases that do not have Erlang on the system,\r\n   you must include `erl_interface` **\r\n\r\n\r\n## Installation\r\n\r\nErlnixify requires ruby 1.9. It does not work on 1.8, but may work on\r\n2.0+ though it has not been tested.\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n    gem 'erlnixify'\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install erlnixify\r\n\r\n## Usage\r\n\r\n### SYNOPSIS\r\n\r\n`erlnixify` [&lt;optional&gt;...] &lt;flags&gt;\r\n\r\n### EXAMPLE\r\n\r\nThe following example shows how to run a bare non-otp erlang\r\nmodule. This is *not* the recommended way to do this at all. You\r\nshould be using Erlang releases, however it does work and it does\r\nillustrate the point.\r\n\r\n    erlnixify --name example \\\r\n              --cookie fubachu \\\r\n              --command \"erl -setcookie %{cookie} -name %{fullname} -noshell -s my_module start\"\r\n\r\nThe above is enough to get things going with the default\r\nvalues. Running a release might be a bit more complicated. Its more\r\ncomplicated because you are going to want to provide a custom check\r\ncommands and perhaps custom check intervals.\r\n\r\n    erlnixify --name example2 \\\r\n              --cookiefile /etc/example2/mycookiefile \\\r\n              --release /opt/example2 \\\r\n              --command '/opt/example2/bin/example2 -setcookie %{cookie} -name=%{fullname} +Ktrue +B -noinput -shutdown_time 5000 +W w' \\\r\n              --check \"example2 check_status\" \\\r\n              --checkregex '^ok$' \\\r\n              --checkinterval 100\r\n\r\nThe above assumes we have a viable OTP Release in the /opt/example2\r\ndirectory. We have placed our cookie in a file in\r\n/etc/example2/mycookiefile and we have a script to start our release\r\nthat lives in the bin directory of the release. We have provided a\r\nmodule `example2` with a function `check_status` that takes no\r\narguments to check the status of the system. If it returns an `ok`\r\neverything is good. We are also going to run that check command every\r\n100 seconds.\r\n\r\n\r\nWe could, of course, have put all the above in a config file as well.\r\n\r\n    name: example2\r\n    cookiefile: /etc/example2/mycookiefile\r\n    release: /opt/example2\r\n    command: /opt/example2/bin/example2 -setcookie %{cookie} -name=%{fullname} +Ktrue +B -noinput -shutdown_time 5000 +W w\r\n    check: example2 check_status\r\n    checkregex: ^ok$\r\n    checkinterval: 100\r\n\r\nThen our Erlnixify could have been much simpler. Assuming our config\r\nfile was at `/etc/example2/erlnixify-config.yaml` or Erlnixify command\r\nline could have been.\r\n\r\n    erlnixify --configfile /etc/example2/erlnixify-config\r\n\r\n\r\n\r\n### Options\r\n\r\n* `-b`, `--release`=&lt;release-root&gt;\r\n\r\n   The root directory of the Release that Erlnixify is\r\n   managing. Erlnixify expects to always be managing a release. This\r\n   is optional if the `erlang` option is provided.\r\n\r\n* `-b`, `--erlang`=&lt;erlang-root&gt;\r\n\r\n   The erlang root directory for the system. This only needs to be\r\n   used if both the `release` option is not specified and the erlang\r\n   install is in a strange place.\r\n\r\n* `-o`, `--home`=&lt;home-dir&gt;\r\n\r\n   The home directory that should be set for the running system. This\r\n   is set by default to the `HOME` directory of the user running\r\n   erlnixify. However, in instances where that should be different or\r\n   the user has no `HOME` directory, this option can be provided.\r\n\r\n* `-n`, `--name`=&lt;short node name&gt;\r\n\r\n   The short node name for this system. This is not\r\n   optional. Erlnixify uses distributed erlang to manage and control\r\n   the Erlang system.\r\n\r\n* `--fullnode`=&lt;full node name&gt;\r\n\r\n  When only `name` is provided, Erlnixify takes the host name of the\r\n  system as provided by `hostname -f` and concatinates it with the\r\n  value provided in `name` to come up with a fully qualified host\r\n  name. The user can use this to override that full name.\r\n\r\n* `-m`, `--command`=&lt;node start command&gt;\r\n\r\n  This is the command that should be used to start the node. This command may contain variables that will be filled out by the Erlnixify system. Those variables are any one of the following.\r\n\r\n  * `release` - as described adove\r\n  * `erlang` - as described above\r\n  * `home` - as described above\r\n  * `name` - as described above\r\n  * `fullname` - The full name of the Erlang node, either as provided\r\n    or as discovered by Erlnixify. This value will always be populated\r\n  * `cookie` - The cookie provided. This value will always be populated\r\n  * `startuptimeout` - as described belov\r\n  * `checkinterval` - as described below\r\n  * `checktimeout` - as described below\r\n\r\n* `-k`, `check`=&lt; the command used to check the status of the system&gt;\r\n\r\n This is an erlang module/function call in\r\n [erl_call](http://www.erlang.org/doc/man/erl_call.html) format. The\r\n default value for this command is `erlang statistics\r\n [reductions]`. However, that is not tremendously useful and you\r\n really should provide your own.\r\n\r\n * `-r`, `--checkregex`=&lt;regular expression&gt;\r\n\r\n  This is a regular expression that is used to check the output of the\r\n  above mentioned check command. If this regular expression does not\r\n  match the output of the check command then the command is expected\r\n  to have failed and the node will be shut down. By default this value\r\n  is `^{\\\\d+, \\\\d+}$`. This matches the default `check` command. If\r\n  you change the `check` command (and you should) you must change this\r\n  value to match your expected output otherwise the system will always\r\n  fail on the first check.\r\n\r\n* `-x`, `--cookiefile`=&lt;path to file that contains the cookie&gt;\r\n\r\n  If the `cookie` option is set this option is not needed. This should\r\n  point to a file that contains the cookie that the system should\r\n  use. That file must contain only the cookie. Be careful that you do\r\n  not include a trailing newline.\r\n\r\n* `-i`, `--cookie`=&lt;cookie value&gt;\r\n\r\n  The actual value that Erlnixify should use as a cookie. This isn't\r\n  needed if the `cookiefile` option is provided.\r\n\r\n* `-t`, `--startuptimeout`=&lt;seconds that the node has to startup&gt;\r\n\r\n  This is the number of seconds that the node has to startup. If the\r\n  node is not running in that amount of time Erlnixify will shut it\r\n  down and exit. The default value is 60.\r\n\r\n* `-a`, `--checkinterval`=&lt;seconds between each check&gt;\r\n\r\n  The number of seconds between each check. The default value is 30.\r\n\r\n\r\n* `-w`, `--checktimeout`=&lt;seconds that the check command is allowed to run&gt;\r\n\r\n  This is the number of seconds that the check command is allowed to\r\n  run. If the check command takes longer then this number of seconds\r\n  then Erlnixify will kill the Erlang node and exit.\r\n\r\n* `-c`, `--config`=&lt;path to config file&gt;\r\n\r\n  The path to a [YAML](http://yaml.org) based config file. The keys\r\n  are the same as described here for the long version of the\r\n  options. A config file is optional if the command line options are\r\n  set instead.\r\n\r\n* `-v`, `--version`\r\n\r\n  Print out the version of Erlnixify\r\n\r\n* `-h`, `--help`\r\n\r\n Print out the help for erlnixify\r\n\r\n## Contributing\r\n\r\nSee [Contributing](https://github.com/erlware/erlnixify/blob/master/CONTRIBUTING.md)<\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}